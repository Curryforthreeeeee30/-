# 单体电商项目架构，开发与上线（一）

### 大型网站架构演进历程



![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_142151.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_142234.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_142725.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_142813.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_142851.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143022.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143045.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143106.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143143.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143213.png)

### 架构师所需具备的技术栈与能力

技术栈：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_143420.png)

能力：

- 技术全面，有广度
- 关注前沿技术
- 全局观、预判
- 把控团队，忙而不乱
- 系统分解与模块拆分
- 指导与培训
- 沟通与协调能力
- 抽象、举例、画图
- 软技能

### 前后端技术选型

**后端技术选型** SpringBoot VS SpringMVC

- SpringMVC是框架，是Spring的子集，是Spring的一个模块
- SpringBoot是工具（配置工具、整合工具）
- 从繁琐配置（xml）到零配置（yml）
- SpringBoot集成了多样化中间件【*-starter】,一定程度上简化了maven的配置
- 从外置tomcat变为内置tomcat

聊一聊Struts

- 安全漏洞，对于技术选型来讲的话，安全性是一定需要考虑的问题。
- 请求变量共享，当用户请求变多的话，由于Action的线程安全问题，导致Action的一些变量可能会出现共享的情况。
- Filter拦截。SpringMVC、SpringBoot是通过AOP实现的，但是Struts是通过类拦截
- 非Spring官方自产自销，当Struts与Spring结合的时候，会略显得有点重。

**前端技术选型**

- MVVM开发模式，去DOM，不是通过DOM去操作结点
- Jquery、Vue.js（渐进式框架）
- html
- css

技术选型所要考虑的

- 切合业务
- 社区活跃度
- 团队技术水平
- 版本更新迭代周期（例如Dubbo停更了一段时间）
- 试错精神
- 安全性
- 开源精神

### 前后端分离开发模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_151253.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_151626.png)

### 项目分层设计原则

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_152033.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_152329.png)

### 构建聚合工程

```
<packaging>pom</packaging>
<packaging>jar</packaging>
<packaging>war</packaging>
```

packaging默认是jar类型，pom、jar、war区别：

https://blog.csdn.net/imaginehero/article/details/103706732

```
<!--
        1、聚合工程里可以分为顶级项目（顶级工程、父工程）与子工程，这两者的关系其实就是父子继承的关系
        子工程在maven里称之为模块（module），模块之间是平级的，是可以相互依赖的。
        2、子模块可以使用顶级工程里所有的资源（依赖），子模块之间如果要使用资源，必须构建依赖（构建关系，把pom坐标拿过来）
        3、一个顶级工程是可以由多个不同的子工程共同组合而成。
-->
```

foodie-dev-common pom.xml

```
<artifactId>foodie-dev-common</artifactId>
```

foodie-dev-pojo pom.xml

```
<!--在pojo中引入common的依赖-->
<dependencies>
    <dependency>
        <groupId>com.wyqian</groupId>
        <artifactId>foodie-dev-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

foodie-dev-mapper pom.xml

```
<dependencies>
    <!--
            mapper->pojo->common
            mapper通过pojo是可以使用common中相应的方法的
        -->
    <dependency>
        <groupId>com.wyqian</groupId>
        <artifactId>foodie-dev-pojo</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

foodie-dev-service pom.xml

```
<dependencies>
    <!--
            service -> mapper -> pojo -> common
            service是可以使用pojo和common中相应的方法的
        -->
    <dependency>
        <groupId>com.wyqian</groupId>
        <artifactId>foodie-dev-mapper</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

foodie-dev-api pom.xml

```
<dependencies>
    <!--
            common-mail
            api -> service -> mapper -> pojo -> common
            api -> common-mail
            api是可以使用service、pojo和common中相应的方法的
        -->
    <dependency>
        <groupId>com.wyqian</groupId>
        <artifactId>foodie-dev-service</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

在引入每一个子模块的时候，需要看一下顶级工程里面里面是不是添加进去了这个子模块，在引入上述这么多子模块之后，顶级工程中 pom.xml

```
<modules>
    <module>foodie-dev-common</module>
    <module>foodie-dev-pojo</module>
    <module>foodie-dev-mapper</module>
    <module>foodie-dev-service</module>
    <module>foodie-dev-api</module>
</modules>
```

在引入子模块完成之后，需要安装一下，建立各个模块之间的依赖关系。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_162955.png)

### PDMan数据库建模工具的使用

我们在真实的业务开发的时候，不会直接在数据库管理工具中创建表，PDMan提供了这样的一个功能，并且出去展示的时候，不可能直接将数据库展示给用户看，PDMan这样的数据库建模工具就显得比较专业。

PDMan下载官网：http://pdman.cn/#/，无脑安装即可。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_170847.png)

连接自己的数据库

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_171338.png)

同步数据库

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_171516.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_171755.png)

### 生产环境增量与全量脚本迭代

重建数据库：新建一张临时表，将当前数据复制到临时表中，然后删除旧表并新建表（把新的字段加上），将数据复制过去！

字段增量：修改原数据库字段。

生产环境中应选择**字段增量**！

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_201049.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-28_200716.png)

### 数据库物理外键移除原因

加外键的好处：1、数据库的完整性；2、强调了数据的强一致性

数据库外键：

- 性能影响。在大并发的情况下，物理外键一定会影响数据库的性能。
- 热更新。热更新就是指不停机进行更新。外键会导致新更新上去的一些代码无法运行，因为需要去匹配现有的一些外键！这时候就需要去重启服务器！
- 降低耦合度。删除物理外键，用逻辑外键代替！
- 数据库分库分表。有外键的话，难以实现分库分表。

总结：在设计一个传统的小型项目的时候，物理外键可以存在，但是在设计一个大型互联网项目的时候是绝对不能存在物理外键的！

### 聚合工程整合SpringBoot

在父项目的pom中引入下面的依赖。使之变成SpringBoot项目，spring-boot-starter-parent中管理了我们很多需要的依赖。

```
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.5.RELEASE</version>
    <relativePath/>
</parent>
```

然后添加编码相关的配置：

```
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <java.version>1.8</java.version>
</properties>
```

然后从parent中取得下面的依赖，可以看到在parent中已经管理好了版本，这里就不需要加版本信息。

```
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <!--
                排除spring-boot-starter-logging的jar包，因为后续我们会引入其他的日志工具！
            -->
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--
            springboot默认会解析yml文件，加上这个依赖，就可以解析别的配置文件！
        -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

让项目跑起来：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_193432.png)

在Controller中写一个HelloController类测试一下：

```
@RestController
public class HelloController {
    @GetMapping("/hello")
    public Object hello(){
        return "Hello World~";
    }
}
```

测试成功页面：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_193540.png)

### SpringBoot自动装配简述

点开主启动类下面的run方法：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_193908.png)

点开@SpringBootApplication注解：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_194500.png)

点开@SpringBootConfiguration注解：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_194911.png)

***SpringBoot怎么实现自动装配的？\***—->spring.factories

点开@EnableAutoConfiguration–>AutoConfigurationImportSelector

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_200224.png)

比如说在SpringBoot中内置的Tomcat是怎么启动的？

打开spring.factories，有一个类叫做EmbeddedWebServerFactoryCustomizerAutoConfiguration，打开：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_200617.png)

点开Tomcat类，可以发现里面有Tomcat所有的操作！这里相当于是配置Tomcat

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_200647.png)

回到spring.factories，点开ServletWebServerFactoryAutoConfiguration类：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_200931.png)

spring.factories中还有WebMvcAutoConfiguration这样的类，帮我们配置好了MVC模块，我们才不用像以前在SpringMVC那样配置XML文件！

### HikariCP数据源简述

HikariCP官网：https://github.com/brettwooldridge/HikariCP

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_202204.png)

SpringBoot默认的数据源。

SpringBoot中已经自动装配好了HikariCP数据源，可以做到开箱即用(无需导入依赖)，如果是在SpringMVC中用，需要导入依赖：

```
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>4.0.3</version>
</dependency>
```

为什么HikariCP很快：https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole

- 把ArrayList换成了自定义的FastList
- 有一个并发包：ConcurrentBag–>无锁设计
- invokevirtual被invokestatic替换掉了，使得更容易被JVM优化。另外：getstatic回调没有了。另外：invokevirtual被invokestatic替换掉了，堆栈从5个减少到了4个。

*HikariCP*和*Druid*的对比：

- 功能角度考虑，Druid 功能更全面，除具备连接池基本功能外，还支持sql级监控、扩展、SQL防注入等。最新版甚至有集群监控。
- 单从性能角度考虑，从数据上确实HikariCP要强，但Druid有更多、更久的生产实践，它可靠。
- 单从监控角度考虑，如果我们有像skywalking、prometheus等组件是可以将监控能力交给这些的 HikariCP也可以将metrics暴露出去。

### 数据层HikariCP与Mybatis整合

1、导入依赖

```
<!--MySQL驱动-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
<!--Mybatis-->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.4</version>
</dependency>
```

2、使用PDMan工具将表导入到数据库中，在application.yml中配置数据源和Mybatis：

```
# web访问端口号  约定8088
server:
  port: 8088
  tomcat:
    uri-encoding: UTF-8
  max-http-header-size: 80KB
############################################################
#
# 配置数据源信息
#
############################################################
spring:
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource # 数据源类型：HikariCP
    driver-class-name: com.mysql.jdbc.Driver # mysql驱动
    url: jdbc:mysql://localhost:3306/foodie-shop-dev?useUnicode=true&characterEncoding=UTF-8&autoReconnect
    username: root
    password: 123456
    hikari:
      connection-timeout: 30000 # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQ
      minimum-idle: 5 # 最小连接数
      maximum-pool-size: 20 # 最大连接数
      auto-commit: true # 自动提交
      idle-timeout: 600000 # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP # 连接池名字
      max-lifetime: 1800000 # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟
      connection-test-query: SELECT 1
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.wyqian.pojo # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml # mapper映射文件
```

3、测试项目是否运行正常。maven需要重新install。重启服务后会出现：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_212451.png)

这是因为在导入的时候，加了一句：排除SpringBoot自带的日志工具

```
<exclusions>
    <exclusion>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-logging</artifactId>
    </exclusion>
</exclusions>
```

可以暂时把这一段注释掉，重启服务，成功！

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-04-29_213317.png)

### 数据源连接数详解

***maximum-pool-size\***：最大连接数。不是越大越好，而是根据服务器来的。比如服务器4核，可以设置为10，如果为8核，则可以设置为20。默认设置为10

***minimum-idle\***：最小连接数。作者是希望和最大连接数保持一致。但是为了不被闲置，可以设置一个小一点的数。

一般可以将这两个数设置成一样！也可以maximum-pool-size设置为大一些，minimum-idle设置为小一些。比如：maximum-pool-size设为20，minimum-idle设为5或者10.

### MyBatis 数据库逆向生成工具

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-01_125306.png)

首先会有一个通用Mapper: MyMapper类：

```
public interface MyMapper<T> extends Mapper<T>, MySqlMapper<T> {
}
```

generatorConfig.xml：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="MysqlContext" targetRuntime="MyBatis3Simple" defaultModelType="flat">
        <property name="beginningDelimiter" value="`"/>
        <property name="endingDelimiter" value="`"/>

        <!-- 通用mapper所在目录 -->
        <plugin type="tk.mybatis.mapper.generator.MapperPlugin">
            <property name="mappers" value="com.imooc.my.mapper.MyMapper"/>
        </plugin>

        <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3306/foodie-shop-dev"
                        userId="root"
                        password="123456">
        </jdbcConnection>

        <!-- 对应生成的pojo所在包 -->
        <javaModelGenerator targetPackage="com.imooc.pojo" targetProject="src/main/java"/>

		<!-- 对应生成的mapper所在目录 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/>

		<!-- 配置mapper对应的java映射 -->
        <javaClientGenerator targetPackage="com.imooc.mapper" targetProject="src/main/java" type="XMLMAPPER"/>

        <!-- 数据库表 -->
		<table tableName="carousel"></table>
		<table tableName="category"></table>
		<table tableName="users"></table>
		<table tableName="user_address"></table>
		<table tableName="items"></table>
		<table tableName="items_img"></table>
		<table tableName="items_spec"></table>
		<table tableName="items_param"></table>
		<table tableName="items_comments"></table>
		<table tableName="orders"></table>
		<table tableName="order_items"></table>
		<table tableName="order_status"></table>

    </context>
</generatorConfiguration>
```

运行GeneratorDisplay

```
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class GeneratorDisplay {

	public void generator() throws Exception {

		List<String> warnings = new ArrayList<String>();
		boolean overwrite = true;
		//指定 逆向工程配置文件
		File configFile = new File("generatorConfig.xml");
		ConfigurationParser cp = new ConfigurationParser(warnings);
		Configuration config = cp.parseConfiguration(configFile);
		DefaultShellCallback callback = new DefaultShellCallback(overwrite);
		MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
				callback, warnings);
		myBatisGenerator.generate(null);

	} 
	
	public static void main(String[] args) throws Exception {
		try {
			GeneratorDisplay generatorSqlmap = new GeneratorDisplay();
			generatorSqlmap.generator();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
}
```

生成：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-01_141148.png)

tk-Mybatis和Mabatis-plus类似，可以极大地提高我们的开发效率。

### 关于Restful webservice的那些事儿

#### Restful Web Service

- 通信方式，比如说RPC通信，Restful也是一种通信方式。
- 信息传递
- 无状态。所有的请求对于接口来说都是无状态的
- 独立性

#### Rest设计规范

- GET 获取资源信息的 也就是查询的操作
- POST 保存信息和更新资源 也可以处理一些批量的操作
- PUT 更新资源操作
- DELETE 删除操作

URL里面不能出现一些动词，如果是动词，转换成名词！

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-02_122648.png)

### 基于通用Mapper基于Rest编写api接口-1

新建一张学生信息表：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-02_213922.png)

1、利用之前的mybatis-generator代码生成器，生成pojo、mapper.xml文件和StuMapper.java文件，并拷贝到我们的项目中。

2、写service。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-02_214225.png)

3、写Controller。

```
@RestController
public class StuFooController {
    @Autowired
    private StuService stuService;

    @GetMapping("/getStu")
    public Stu getStu(int id){
        return stuService.getStuInfo(id);
    }
}
```

但是直接这样启动会报错，原因是mapper并未扫描到我们的Spring中，这时候要在主启动类上加上一条注解：

```
//扫描mybatis通用mapper下所在的包
@MapperScan(basePackages = "com.wyqian.mapper")
```

注意@MapperScan要选：tk包下的

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/1619963132(1).png)

4、测试成功：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-02_214625.png)

另：由于idea的原因，导致这里会出现红线：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_091028.png)

为了去除红线，可以在settings里面设置一下：

搜索Inspections—–>Spring 去掉Autowiring for bean class的方框勾选即可。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_091233.png)

### 基于通用Mapper基于Rest编写api接口-2

同理，完善保存、更新和删除学生的部分

1、写service.

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_102636.png)

2、写Controller.

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_091947.png)

这里需要注意的是，我们按照Restful设计规范，查询操作使用GetMapping，保存、更新和删除操作使用PostMapping。

谈谈***幂等性\***：
幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。

在我们这里，更新操作和删除操作是具备幂等性的，但是保存就不具备幂等性了，因为每次保存都有可能是不一样的值。

### 使用PostMan调试Restful接口

我们使用的PostMapping接口，是不可以直接使用浏览器进行调试的，但是可以借用调试工具，比如说PostMan。

下载地址：https://www.postman.com/downloads/

1、Get请求

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_100149.png)

2、Post请求—保存操作

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_100326.png)

去数据库中查看一下，数据已经持久化完成：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_100314.png)

多次重复同一个请求：http://localhost:8088/saveStu：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_100539.png)

3、Post请求—更新操作

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_102721.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_102731.png)

4、Post请求—删除操作

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_102826.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_102837.png)

彩蛋：ctrl+F12可以将当前类中的方法、属性以列表的形式展示出来！

### 详解事务的传播

***@Transactional\***

默认值：![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_103248.png)

#### REQUIRED

**Propagation.REQUIRED**：一定要使用事务，如果没有的话就创建事务，如果有的话就使用当前的事务。

准备工作：

1、先写一个TestTransactionalService 接口：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_112836.png)

2、在StuServiceImpl中实现TestTransactionalService接口：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_113003.png)

3、写一下TestTransactionalServiceImpl，将saveParent()和saveChildren()引入：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_113129.png)

测试：

1、首先，父Service和子Service都不加事务：

```
父Service：
    public void testPropagationTrans();
子Service：
    public void saveChildren();
```

结果报除零错误，数据库中2条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_113503.png)

2、父Sercice加事务，子Service不加事务：

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    public void saveChildren();
```

结果报除零错误，数据库中没有数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_113730.png)

3、父Service不加事务，子Service加事务：

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveChildren();
```

结果报除零错误，数据库中有1条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_114040.png)

总结：

REQUIRED：使用当前的事务，如果没有加入事务，则自己新建一个事务，子方法是必须运行在一个事务的，如果当前存在事务，则加入这个事务，成为一个整体。

举例：领导没饭吃，我有钱，我会自己买了自己吃；领导有的吃，会分给你一起吃。

#### SUPPORTS

测试：

1、父Service不加事务，子Service加事务：

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.SUPPORTS)
    public void saveChildren();
```

结果报除零错误，数据库中有2条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_114953.png)

2、父Service加事务，子Service加事务：

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.SUPPORTS)
    public void saveChildren();
```

结果报除零错误，数据库中没有数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_115145.png)

总结：如果当前有事务，则使用事务；如果当前没有事务，则不使用事务。

举例：领导没饭吃，我也没饭吃；领导有饭吃，我也有饭吃。

#### MANDATORY

测试：

1、父Service不加事务，子Service加事务：

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.MANDATORY)
    public void saveChildren();
```

结果报错：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_115909.png)

这是由于父Service不加事务所导致的。

数据库中有1条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_120012.png)

2、父Service加事务，子Service加事务：

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.MANDATORY)
    public void saveChildren();
```

结果报除零错，数据库中没有数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-03_120140.png)

总结：该传播属性强制必须存在一个事务，如果不存在，则抛出异常。

举例：领导必须管饭，不管饭没饭吃，我就不乐意了，就不干了（抛出异常）。

#### REQUIRES_NEW

测试：

1、父Service不加事务，子Service加事务

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveChildren();
```

结果报除零错，数据库中有1条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_153313.png)

2、父Service加事务，子Service加事务

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveChildren();
```

并修改一下除零错的位置：

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveChildren(){
    saveChild1();
    //int i = 1 / 0;
    saveChild2();
}
@Transactional(propagation = Propagation.REQUIRED)
public void testPropagationTrans(){
    stuService.saveParent();
    stuService.saveChildren();
    int i = 1 / 0;
}
```

结果报除零错，数据库中有2条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_153659.png)

如果将子Service上的`REQUIRES_NEW`改为`REQUIRED`的话，那么数据库中就没有数据！这就是`REQUIRES_NEW`和`REQUIRED`的区别。

总结：如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；

如果没有事务，则同REQUIRED。

举例：领导有饭吃，我偏不要，我自己买了自己吃。

#### NOT_SUPPORTED

1、父Service不加事务，子Service加事务

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void saveChildren();
```

结果报除零错，数据库中有2条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_154839.png)

2、父Service加事务，子Service加事务

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void saveChildren();
```

结果报除零错，数据库中有1条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_155049.png)

总结：如果当前有事务，则把事务挂起，自己不使用事务去运行数据库操作。

举例：领导有饭吃，分一点你给你，我太忙了，放一边，我不吃。

#### NEVER

1、父Service加事务，子Service加事务

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NEVER)
    public void saveChildren();
```

结果：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_164337.png)

数据库中没有数据。

2、父Service不加事务，子Service加事务

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NEVER)
    public void saveChildren();
```

结果报除零错，数据库中有2条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_164657.png)

总结：如果当前有事务存在，则抛出异常

举例：领导有饭吃，我不想吃，我热爱工作，我抛出异常！

#### NESTED

1、父Service不加事务，子Service加事务

```
父Service：
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NESTED)
    public void saveChildren();
```

结果报除零错，数据库中有1条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_165830.png)

2、父Service加事务，子Service加事务

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NESTED)
    public void saveChildren();
```

并修改一下除零错的位置：

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveChildren(){
    saveChild1();
    //int i = 1 / 0;
    saveChild2();
}
@Transactional(propagation = Propagation.REQUIRED)
public void testPropagationTrans(){
    stuService.saveParent();
    stuService.saveChildren();
    int i = 1 / 0;
}
```

结果报除零错，数据库中没有数据！

3、父Service加事务，子Service加事务

```
父Service：
    @Transactional(propagation = Propagation.REQUIRED)
    public void testPropagationTrans();
子Service：
    @Transactional(propagation = Propagation.NESTED)
    public void saveChildren();
```

再修改一下除零错的位置：

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveChildren(){
    saveChild1();
    int i = 1 / 0;
    saveChild2();
}
@Transactional(propagation = Propagation.REQUIRED)
public void testPropagationTrans(){
    stuService.saveParent();
    stuService.saveChildren();
    //int i = 1 / 0;
}
```

结果还是没有数据！

4、在3的基础上使用try catch设置保存点。

```
@Transactional(propagation = Propagation.REQUIRED)
public void testPropagationTrans(){
    stuService.saveParent();

    try {
        stuService.saveChildren();
    } catch (Exception e) {
        e.printStackTrace();
    }
    //int i = 1 / 0;
}
```

执行代码，结果正确，并且数据库中有一条数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_170538.png)

总结：如果当前有事务，则开启子事务（嵌套事务），嵌套事务可以独立提交或者回滚；

如果当前没有事务，则同REQUIRED；

但是如果主事务提交，则会携带子事务一起提交。

如果主事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以回滚或不回滚。

举例：领导决策不对，老板怪罪，领导带着小弟一同受罪。小弟出了差错，领导可以推卸责任。

### 为何不使用@EnableTransactionManagement就能使用事务？

所谓开启事务管理，就是：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_183539.png)

但是，我们在讲事务传播的时候并没有加这条注解，但是事务依然生效，这是因为SpringBoot帮我们自动注入了事务管理！

spring.factories中：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_183313.png)

TransactionAutoConfiguration配置类中可以看到它通过Spring AOP实现的。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_184015.png)

### 详细讲解注册登录流程

实现单体电商项目核心功能：

- 用户注册与登录
- Cookie与Session
- 集成Swagger2 api
- 分类设计与实现
- 首页商品推荐
- 商品搜索与分页
- 商品详情与评论渲染
- 购物车与订单
- 微信和支付宝支付

#### 用户注册和登录流程

一般有3种方式：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_185215.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_185542.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-05_185708.png)

### 用户注册-判断用户名存在

密码与确认密码不一致，前后端都要做！

- 前端做的话是为了减轻服务端的压力
- 后端做的话是为了防止某些用户绕过前端，直接访问服务器，如果服务端没有做验证的话，就可能造成黑客的攻击。

在集群、微服务、分布式的环境下，所有的表id必须全局唯一！除非表的访问量非常非常小，表的数据量只有十几条，几十条，上百上千这种可以使用自增长。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_134157.png)

我们应该从底层往上写：

1、新建一个UserService，

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_142152.png)

2、实现UserServiceImpl

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_142227.png)

3、写接口PassportController

这里用到了一个apache的工具类，判断字符串是否为空。所以要先导包：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_142434.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_142319.png)

### 自定义响应数据结构

写好了接口之后，测试！

由于我们修改了服务端代码，所以需要重新安装各个模块之间的关系，install一下！

会发现报错了：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_142735.png)

这是由于maven在install的时候会帮我们把测试（junit）下的跑一下，所以这里我们将相关测试代码注释掉：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_143128.png)

再次install，BUILD SUCCESS!

启动Application，报错：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_144928.png)

springboot的事务默认是使用jdk的动态代理，即基于接口。而在注入***Impl的时候是实现类，所以我们将代理模式改成基于实现类的代理模式：

只需要在主启动类上将：

```
@EnableTransactionManagement
```

改成：

```
@EnableTransactionManagement(proxyTargetClass=true)
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_145707.png)

修改之后，再次测试，成功！

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_144648.png)

这里的返回值都是写死的，在RESTFUL Service里面其实是返回的状态码，于是乎，可以将代码修改一下：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_150226.png)

这里，HttpStatus是一个枚举类。再次测试：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_150426.png)

这里返回OK，可以看源码：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_150349.png)

在后端的话，我们可以将状态码和一些业务数据封装在一起。

于是，写了一个工具类：IMOOCJSONResult.java

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_170017.png)

这个类中主要的属性只有三个，这样我们就可以将响应的状态、响应消息和响应的数据封装在一起，前端可以自行根据业务需求调用。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_170149.png)

因此，我们将Controller中的内容再做修改：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_170131.png)

install maven项目，重启，再次测试：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_170449.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-06_170539.png)

### 用户注册-创建用户Service

1、完成Service接口部分：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_214133.png)

这里使用UserBO，是将前端传过来的Json Object封装成了一个Java类：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_214244.png)

2、写Service的实现

```
@Transactional(propagation = Propagation.REQUIRED)
@Override
public Users createUser(UserBO userBO) {
    Users user = new Users();
    //设置用户id
    String userId  = sid.nextShort();
    user.setId(userId);
    //设置用户名
    user.setUsername(userBO.getUsername());
    //设置密码
    try {
        user.setPassword(MD5Utils.getMD5Str(userBO.getPassword()));
    } catch (Exception e) {
        e.printStackTrace();
    }
    //默认昵称同用户名
    user.setNickname(userBO.getUsername());
    //设置默认头像
    user.setFace(USER_FACE);
    //设置生日
    user.setBirthday(DateUtil.stringToDate("1900-01-01"));
    //设置性别
    user.setSex(Sex.secret.type);
    //设置创建时间和更新时间
    user.setCreatedTime(new Date());
    user.setUpdatedTime(new Date());

    usersMapper.insert(user);

    return user;
}
```

这里的注意点有：

1、设置密码的时候需要加密，防止黑客攻击服务器的时候用户信息泄露，这里我们采用的是MD5加密方式。工具类：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_214542.png)

2、用户默认头像图片地址：

```
private static final String USER_FACE = "http://122.152.205.72:88/group1/M00/00/05/CpoxxFw_8_qAIlFXAAAcIhVPdSg994.png";
```

3、设置生日。使用了一个工具类，将字符串转成Date格式，工具类：
![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_214845.png)

4、设置性别。写了一个枚举类，枚举类如下：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_214950.png)

5、设置用户id，这里为了保证全局唯一，使用了工具类生成，工具类：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_215123.png)

这里需要注意两点，第1、是在Spring中注入Sid类。第2、工具类所在的包需要被SpringBoot扫描到，所以在主启动类上需要加入注解：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-07_215412.png)

### 用户注册-创建用户controller与测试

之前的passPort里面写，注意点有：

1、需要考虑注册不成功的几种情况：

- 用户名和密码不能为空
- 用户名不能是已经注册过的，也就是数据库中已经存在的
- 密码必须大于6位
- 密码和确认密码必须一致

2、@RequestBody的作用：

将前端传过来的Json Object转化成Java Class UserBO。

3、由于这里是保存操作，所以使用PostMapping映射方式。

代码：

```
@PostMapping("/regist")
//@RequestBody作用是什么？--->将前端传过来的Json Object转化成Java class
public IMOOCJSONResult regist(@RequestBody UserBO userBO){
    String username = userBO.getUsername();
    String password = userBO.getPassword();
    String confirmPwd = userBO.getConfirmPassword();
    //0. 用户名和密码不能为空
    if(StringUtils.isBlank(username) ||
       StringUtils.isBlank(password) ||
       StringUtils.isBlank(confirmPwd)){
        return IMOOCJSONResult.errorMsg("用户名和密码不能为空");
    }
    //1. 查询用户名是否存在
    boolean isExist = userService.queryUserNameIsExist(username);
    if(isExist){
        return IMOOCJSONResult.errorMsg("用户名已经存在");
    }
    //2. 密码不能少于6位
    if(password.length() < 6){
        return IMOOCJSONResult.errorMsg("密码不能少于6位");
    }
    //3. 两次输入的密码必须保持一致
    if(!password.equals(confirmPwd)){
        return IMOOCJSONResult.errorMsg("两次输入的密码不一致");
    }
    //4. 实现注册
    userService.createUser(userBO);
    return IMOOCJSONResult.ok();
}
```

测试：这里由于需要传递的是Json数据，在PostMan里面需要选择Body->raw->JSON。

1、用户名和密码为空：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-08_091111.png)

2、用户名已经存在：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-08_091619.png)

3、密码少于6位：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-08_091252.png)

4、两次密码不一致：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-08_091232.png)

5、注册成功：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-08_091607.png)

### 整合Swagger2文档api

 为了减少程序员撰写文档时间，提高生产力，Swagger2应运而生，使用Swagger2可以减少编写过多的文档，只需要通过代码就能生成文档API，提供给前端人员对接，非常方便。

1、引入依赖：

```
<!-- swagger2 配置 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>swagger-bootstrap-ui</artifactId>
    <version>1.6</version>
</dependency>
```

第一个依赖是核心。前两个依赖是官方提供的，最后一个是其他开发人员开发的。

2、写Swagger2配置类：

```
@Configuration
@EnableSwagger2//开启Swagger2
public class Swagger2 {

    //http:localhost:8088/swagger-ui.html     原路径
    //http:localhost:8088/doc.html     换肤

    //配置Swagger2核心配置   docket
    @Bean
    public Docket createDocket(){
        return new Docket(DocumentationType.SWAGGER_2)                                   //指定api类型为Swagger2
                    .apiInfo(apiInfo())                                                  //用于定义api文档汇总信息
                    .select()
                    .apis(RequestHandlerSelectors.
                            basePackage("com.wyqian.controller"))                        //指定controller包
                    .paths(PathSelectors.any())                                          //所有controller
                    .build();
    }
    private ApiInfo apiInfo(){
        return new ApiInfoBuilder()
                .title("天天吃货 电商平台接口api")         //文档页标题
                .contact(new Contact("wyqian",
                        "http://wyqian.top/",
                      "wanyun_qian@163.com")
                        )                               //联系人信息
                .description("专为天天吃货提供的api文档")  //详细信息
                .version("1.0.1")                       //文档版本号
                .termsOfServiceUrl("http://wyqian.top/")//网站地址
                .build();
    }
}
```

在这里，使用了两种ui来展示，一种是Swagger自带的方式，另一种是使用了BootStrap美化后的ui。分别如下：

![img](https://wyqian.top/2021/04/27/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89/H:%5Chexoblog%5Cblog%5Csource_posts%5C%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89%5C2021-05-11_202048.png)

![img](https://wyqian.top/2021/04/27/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89/H:%5Chexoblog%5Cblog%5Csource_posts%5C%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%80%EF%BC%89%5C2021-05-11_202057.png)

### 优化Swagger2显示

1、如果有一些controller不想展示（比如：隐私或者测试接口等等），可以使用`@ApiIgnore`注解：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_202736.png)

在HelloController和StuFooController上面使用该注解，重启项目：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_202616.png)

另外两个接口不见了！

2、将英文展示变成中文展示，对开发人员更友好！

加在Controller类上的

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_203943.png)

加在方法上的（POST提交）：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_203950.png)

加在方法上的（GET提交）：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_203956.png)

重启，查看ui页面：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_204125.png)

3、上述请求参数展示为空，可以在pojo类里配置：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_205039.png)

重启，查看ui页面：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_205211.png)

### 使用tomcat运行前端源码

插曲：解决tomcat启动闪退的办法：

在shutup.bat和shutdown.bat的文件最前面加上：

```
SET JAVA_HOME=C:\Program Files\Java\jdk1.8.0_152
SET TOMCAT_HOME=D:\Environment\apache-tomcat-9.0.39-windows-x64\apache-tomcat-9.0.39
```

1、将foodie-shop静态资源文件夹复制到tomcat–>webapps目录下

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_211129.png)

2、启动tomcat(双击shutup.bat)，在浏览器中输入url：http://localhost:8080/foodie-shop：（文件夹名即为访问路径）

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_211307.png)

### 设置跨域配置实现前后端联调

跨域：前端静态资源放在了tomcat的8080端口，而后端的代码是在8088端口，前端请求后端的时候，两个端口完全不同，这就是跨域。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_215154.png)

解决跨域问题：

1、前端配置后端服务地址serverurl：

将

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_215338.png)

修改成后端所在的接口服务地址：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-11_215511.png)

2、在后端写一个关于跨域的配置类corsConfig，允许[http://localhost:8080地址的前端资源访问后端服务器。](http://localhost:8080地址的前端资源访问后端服务器。/)

```
@Configuration
public class CorsConfig {
    public CorsConfig() {
    }

    @Bean
    public CorsFilter corsFilter(){
        //1、添加cors配置信息
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://localhost:8080");

        //设置是否发送cookie信息
        config.setAllowCredentials(true);

        //设置允许请求的方式
        config.addAllowedMethod("*");

        //设置允许的header
        config.addAllowedHeader("*");

        //2、为url添加映射路径
        UrlBasedCorsConfigurationSource corsSource = new UrlBasedCorsConfigurationSource();
        corsSource.registerCorsConfiguration("/**", config);

        //3、返回重新定义好的corsSource
        return new CorsFilter(corsSource);

    }
}
```

3、重启项目，测试：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-12_222619.png)

后端数据库中的数据：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-12_222730.png)

可以看到，当用户名输入框输入wyqian的时候，下方已经显示了用户名已经存在的红色消息，这是通过Vue中的前后端交互工具axios实现的，相关的前端源码为;

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-12_222914.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-12_223122.png)

### 实现用户登录

1、写Service接口

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_090450.png)

2、在UserServiceImpl类中实现上面的方法。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_090552.png)

3、写Controller，可以把前面注册的代码拿过来修改即可。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_090651.png)

这里需要注意两点：

1、前端拿到的password需要经过MD5加密之后与后端数据库中的数据作比较。

2、由于登陆操作不需要写confirmPassword，所以UserBO实体类中，将confirmPassword属性的swagger注解的required设置成false。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_091015.png)

4、maven项目重新install，重启项目。

- swagger-ui页面测试：

  ![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_092304.png)

- 真实项目测试也没有问题，登陆成功！

这部分前端源码展示：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_092412.png)

其中，res就是从后端拿到的数据，为了查看拿到的数据，这里我们加上debugger，在浏览器中测试，可以看到res中有我们后端的IMOOCJSONResult对象数据。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210513092026.png)

### 回顾cookie和session

cookie:

- 以键值对形式存储信息在浏览器，其实就是存储在浏览器上的缓存。cookie大小是有限制的，一般不能超过4KB。
- cookie不能跨域，当前及其父级域名可以取值
- cookie可以设置有效期
- cookie可以设置path

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_094147.png)

session:

- 基于服务器内存的缓存（非持久化），可保存请求会话。
- 每个session通过sessionid来区分不同请求。
- session可设置过期时间
- session也是以键值对形式存在的。

Session例子：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_100224.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_100143.png)

### 实现用户信息在页面显示

通过cookie实现！

1、导入CookieUtils和JsonUtils工具类

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_103642.png)

2、在login接口中设置cookie。注意这里由于安全性考虑（比如说公用电脑，个人信息保存在cookie中不安全等），需要将一些属性赋为空，才能传到前端。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_103911.png)

其中，cookie名”user”是与前端对应的：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_104026.png)

3、启动测试。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210513103233.png)

4、注册的接口也加上同样的设置cookie代码。测试：

1. 首先退出当前登录，这里由于还没做退出登陆的功能，所以直接删除浏览器中cookie信息：

   ![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_104500.png)

2. 点击注册。注册完毕后首页：

   ![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_104613.png)

### 整合log4j打印日志

由于springboot自带的日志框架有些冗余，我们可以剔除springboot自带的日志框架：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_111128.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_110644.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_110836.png)

添加日志框架依赖：

```
<!--引入日志依赖 抽象层 与 实现层-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.21</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.21</version>
</dependency>
```

引入依赖后重启项目，控制台信息：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_112124.png)

加上配置文件：log.properties，控制台消息正常！

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_112332.png)

测试日志级别：

```
public class HelloController {

    //定义一个logger
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    @GetMapping("/hello")
    public Object hello(){
        logger.info("info: hello,nju!");
        logger.warn("warn: hello,nju!");
        logger.debug("debug: hello,nju!");
        logger.error("error: hello,nju!");
        return "Hello World~";
    }
}
```

启动项目，访问http://localhost:8088/hello，控制台消息：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_123101.png)

可以看到日志级别为info级别的情况下，是看不到debug的消息的。重新设置，改成DEBUG：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_123358.png)

再次启动项目，访问http://localhost:8088/hello，控制台消息为：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-13_123517.png)

这时候DEBUG级别的消息也打印了出来。

### 通过日志监控service执行时间

1、导入AOP的包

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

2、由于通过日志监控service执行时间是通过AOP实现的，于是乎，在foodie-dev-api下新建一个aspect包，然后新建一个类，并写一个切入的方法。

这里采用的是环绕通知。

```
@Aspect//标注这个类是一个切面
@Component
public class ServiceLogAspect {
    /**
     * AOP通知：
     * 1、前置通知：在方法调用之前执行
     * 2、后置通知：在方法正常调用之后执行
     * 3、环绕通知：在方法调用之前和之后，都分别可以执行的通知
     * 4、异常通知：如果载方法调用过程中发生异常，则通知
     * 5、最终通知：在方法调用之后执行，与2区别开来，可以理解为try catch里面的finally
     */
    private static final Logger log =
            LoggerFactory.getLogger(ServiceLogAspect.class);

    /**
     * 切面表达式：
     * execution  代表所要执行的表达式主体
     * 第一处 * 代表方法返回类型，*代表所有类型
     * 第二处 包名代表aop监控的类所在的包
     * 第三处 .. 代表该包及其子包下的所有类方法
     * 第四处 * 代表类名  *代表所有类
     * 第五处 *(..) *表示类中的方法名，(..)表示方法中的任何参数
     * @param joinPoint
     * @return
     * @throws Throwable
     */
    @Around("execution(* com.wyqian.service.serviceImpl..*.*(..))")
    public Object recordTimeLog(ProceedingJoinPoint joinPoint) throws Throwable {
        log.info("===== 开始执行 {}.{} =====",
                        joinPoint.getTarget().getClass(),
                        joinPoint.getSignature().getName());
        //记录开始时间
        long start = System.currentTimeMillis();

        //执行目标
        Object result = joinPoint.proceed();
        
        //记录结束时间
        long end = System.currentTimeMillis();
        long takeTime = end - start;

        if(takeTime > 3000){
            log.error("===== 执行结束，耗时：{}毫秒 =====", takeTime);
        }else if(takeTime > 2000){
            log.warn("===== 执行结束，耗时：{}毫秒 =====", takeTime);
        }else{
            log.info("===== 执行结束，耗时：{}毫秒 =====", takeTime);
        }

        return result;
    }
}
```

这里注意一个写法：

```
@Around("execution(* com.wyqian.service.serviceImpl..*.*(..))")
```

我们之前写的是这样的：

```
@Around("execution(* com.wyqian.service.UserServiceImpl.*(..))")
```

发现比上面的写法少了..*，这是因为serviceImpl是一个包，加..星是因为.. 代表该包及其子包下的所有类方法，而星表示所有类。而之前的写法中UserServiceImpl本身就是一个类！

3、重启项目，测试

- 1、我们执行了一个登陆操作：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_094700.png)

- 2、我们加入休眠代码，创造error和warn级别的日志。

  ![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_095046.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_095117.png)

再次测试，结果：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_095031.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_095244.png)

由于在log.properties中配置了写入到文件，所以在本地也会有日志记录：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_100939.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_101146.png)

### 用户退出登录清空cookie

前端源码：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_102931.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_102554.png)

因此，我们需要在passport中新加一个logout的接口：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_102554.png)

测试：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_102812.png)

### 开启Mybatis日志Sql打印

在生产环境中，我们一般不会去打印出SQL语句，但是在开发环境中，开启SQL日志，可以帮助我们更好定位和判断哪里写错了。

在Mybatis的配置文件处，加上一条关于日志的配置，这里我们选择stdoutImpl:

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_104243.png)

重启项目，测试：

登录操作：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_104448.png)

注册操作：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/2021-05-14_104636.png)