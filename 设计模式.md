# 设计模式

### 导论



主要分为：

- 创建型模式
- 结构型模式
- 行为型模式
- 设计模式原则

什么是GOF（四人组）？

 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。

注意两点：

- ***对接口编程而不是对实现编程\***
- ***优先使用对象组合而不是继承\***

设计模式的基石：

- 封装
- 继承
- 多态
- 顺序
- 判断
- 循环

设计模式总览：
![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210616094540.png)

为什么要有这些设计模式—从组件的生命周期来看：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210616094710.png)

但是经常会有黏合，比如在考虑组建的定义的时候，我们也会要考虑一些行为模式等。

设计模式的七大原则：

1. 开闭原则：扩展新类而不是修改旧类。
2. 里氏替换原则：继承父类而不是改变父类。
3. 依赖倒置原则：面向接口编程，而不是面向实现类。
4. 单一职责原则：每个类只负责自己的事情，而不是变成万能。
5. 接口隔离原则：每个类建立自己的专用接口，而不是建立万能接口。
6. 迪米特法则：无需交互的两个类，如果需要交互，使用中间者。但是过度使用迪米特法则会使系统产生大量的中间类，从而增加系统的复杂性，使模块之间的通信效率降低。
7. 合成复用原则：优先组合，其次继承。

### 创建型模式-为什么使用创建型模式

难度（由易到难）：创建型模式—>结构型模式—>行为型模式

创建型模式有：

1. 单例模式
2. 原型模式
3. 工厂方法模式
4. 抽象工厂模式
5. 建造者模式

其中，3和4可以统称为工厂模式。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210618102344.png)

### 创建型模式-单例的演示

单例模式：一个单一的类，负责创建自己的对象，同时确保系统中只有单个对象被创建。

单例的特点：

- 某个类只能有一个实例；（构造器私有）
- 它必须自行创建这个实例；（自己编写实例化逻辑）
- 它必须自行向整个系统提供这个实例；（对外提供实例化方法）

懒汉式

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //懒汉式
    private static Person instance;

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static Person guiguBoss(){
        //如果没有再去创建
        if(instance == null){
            Person person = new Person();
            instance = person;
        }
        return instance;
    }
}
```

饿汉式

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //饿汉式
    private final static Person instance = new Person();

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static Person guiguBoss(){
        return instance;
    }
}
```

考察更多的是懒汉式。但是普通的懒汉式会有并发问题。解决方法：

1、在方法上加上一个synchronized

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //懒汉式
    private static Person instance;

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static synchronized Person guiguBoss(){
        //如果没有再去创建
        if(instance == null){
            Person person = new Person();
            instance = person;
        }
        return instance;
    }
}
```

2、在代码块上加一个synchronized

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //懒汉式
    private static Person instance;

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static Person guiguBoss(){
        synchronized (Person.class){
            //如果没有再去创建
            if(instance == null){
                Person person = new Person();
                instance = person;
            }
        }
        return instance;
    }
}
```

3、双重检查锁

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //懒汉式
    private static Person instance;

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static Person guiguBoss(){
        //如果没有再去创建
        if(instance == null){
            synchronized (Person.class){
                if(instance == null){
                    Person person = new Person();
                    //多线程问题
                    instance = person;
                }
            }
        }
        return instance;
    }
}
```

但是这样还不是最好的，比如说还会存在指令重排问题。加上一个volatile

```
package com.wyqian.design.creatation.singleton;

public class Person {
    private String name;
    private String age;

    //懒汉式
    private volatile static Person instance;

    //构造器私有，外部不能实例化
    private Person(){
        System.out.println("创建了person");
    }

    //提供给外部的方法
    public static Person guiguBoss(){
        //如果没有再去创建
        if(instance == null){
            synchronized (Person.class){
                if(instance == null){
                    Person person = new Person();
                    //多线程问题
                    instance = person;
                }
            }
        }
        return instance;
    }
}
```

### 创建型模式-单例的应用场景

什么场景用到：

- 多线程中的线程池
- 数据库的连接池
- 系统环境信息
- 上下文（ServletContext）

比如：获取系统当前属性：

```
Properties properties = System.getProperties();
System.out.println(properties);
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621112303.png)

获取当前系统环境

```
Map<String, String> env = System.getenv();
System.out.println(env);
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621112612.png)

这些就是电脑高级属性里配置的环境变量。

每一个类、每一个框架想要获取当前环境变量的时候，没有必要把所有的环境变量拿过来创建对象再交给它，而是使用单例。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621134604.png)

### 创建型模式-原型模式

原型模式：用于创建重复的对象，又能保证性能。本体给外部提供一个克隆体进行使用。

什么场景用到：

- 资源优化
- 性能和安全要求
- 一个对象多个修改者的场景
- 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以考虑使用原型模式拷贝多个对象供调用者使用。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621145438.png)

User.java

```
package com.wyqian.design.creatation.prototype;

/**
 * 当前对象是可克隆的
 */
public class User implements Cloneable{
    private String username;
    private Integer age;

    public User() {
        System.out.println("User对象被创建");
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }

    /**
     * 再创建一个人，赋予我的所有属性
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        User user = new User();
        user.setUsername(this.username);
        user.setAge(this.age);
        return user;
    }
}
```

GuiguMybatis.java

```
package com.wyqian.design.creatation.prototype;

import java.util.HashMap;
import java.util.Map;

public class GuiguMybatis {
    //缓存User
    private Map<String, User> userCache = new HashMap();

    /**
     *从数据库查数据
     * @param username
     * @return
     */
    public User getUser(String username) throws Exception{
        User user = null;
        //缓存中没有
        if(!userCache.containsKey(username)){
            //查数据库
            user = getUserFromDb(username);
        }else{
            //从缓存中直接拿
            //原型已经拿到，但是不能直接给（本人）
            user = userCache.get(username);
            System.out.println("从缓存中拿到的是："+user);
            //从这个对象快速获得一个克隆体（克隆人）==原型模式
            user = (User)user.clone();
        }
        return user;
    }

    private User getUserFromDb(String username) throws Exception{
        System.out.println("从数据库中查到：" + username);
        User user = new User();
        user.setUsername(username);
        user.setAge(18);
        //给缓存中放一个克隆
        userCache.put(username, (User)user.clone());
        return user;
    }
}
```

MainTest测试类：

```
package com.wyqian.design.creatation.prototype;

/**
 * 是用于创建重复的对象，同时又能保证性能。
 * 1、GuiguMyBatis：操作数据库，从数据库里面查出很多记录（70%改变很少）
 * 2、每次查数据库，查到以后把所有数据都封装一个对象，返回。
 *    10000 thread：查一个记录： new User("zhangsan",18)；每次创建一个对象封装并返回
 *    系统里面就会有10000个User;浪费内存
 * 3、解决：缓存；查过的保存。
 *          如果再查相同的记录，拿到原来的原型对象
 * 4、此时直接拿到缓存中的对象。
 */
public class MainTest {
    public static void main(String[] args) throws Exception{
        GuiguMybatis mybatis = new GuiguMybatis();

        //得到的是克隆体
        User zhangsan1 = mybatis.getUser("zhangsan");
        System.out.println("1==>"+zhangsan1);
        zhangsan1.setUsername("李四2");
        System.out.println("zhangsan1自己改了：" + zhangsan1);

        //得到的是克隆体
        User zhangsan2 = mybatis.getUser("zhangsan");
        System.out.println("2-->"+zhangsan2);

        //得到的是克隆体
        User zhangsan3 = mybatis.getUser("zhangsan");
        System.out.println("3-->"+zhangsan3);

        //得到的是克隆体
        User zhangsan4 = mybatis.getUser("zhangsan");
        System.out.println("4-->"+zhangsan4);

        System.out.println(zhangsan1 == zhangsan3);
    }
}
```

### 创建型模式-简单工厂模式

工厂模式：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621152237.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621152343.png)

抽象类：AbstractCar.java

```
/**
 * 工厂的产品
 */
public abstract class AbstractCar {
    String engine;
    public abstract void run();
}
```

两个具体产品：MiniCar.java和AbstractCar.java

```
package com.wyqian.design.creatation.factory.simplefactory;

/**
 * 具体产品
 */
public class MiniCar extends AbstractCar {
    public MiniCar() {
        this.engine = "单缸发动机";
    }

    @Override
    public void run() {
        System.out.println(this.engine + "哒哒哒...");
    }
}
package com.wyqian.design.creatation.factory.simplefactory;

/**
 * 具体产品
 */
public class VanCar extends AbstractCar{
    public VanCar() {
        this.engine = "四缸发动机";
    }

    @Override
    public void run() {
        System.out.println(this.engine + "嘟嘟嘟...");
    }
}
```

工厂：

```
package com.wyqian.design.creatation.factory.simplefactory;

/**
 * 简单工厂
 * 1、产品数量极少
 */
public class WulinSimpleFactory {

    public AbstractCar newCar(String type){
        if("van".equals(type)){
            return new VanCar();
        }else if("mini".equals(type)){
            return new MiniCar();
        }
        return null;
    }
}
```

测试类：

```
package com.wyqian.design.creatation.factory.simplefactory;

public class MainTest {
    public static void main(String[] args) {
        WulinSimpleFactory factory = new WulinSimpleFactory();
        AbstractCar car1 = factory.newCar("van");
        AbstractCar car2 = factory.newCar("mini");
        car1.run();
        car2.run();
    }
}
```

### 创建型模式-工厂方法模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621212236.png)

1、抽象产品

```
/**
 * 工厂的产品
 */
public abstract class AbstractCar {
    String engine;
    public abstract void run();
}
```

2、具体产品

MiniCar

```
/**
 * 具体产品
 */
public class MiniCar extends AbstractCar {
    public MiniCar() {
        this.engine = "单缸发动机";
    }

    @Override
    public void run() {
        System.out.println(this.engine + "哒哒哒...");
    }
}
```

RacingCar

```
package com.wyqian.design.creatation.factory.factorymethod;

public class RacingCar extends AbstractCar{
    public RacingCar(){
        this.engine = "v8发动机";
    }
    public void run() {
        System.out.println(engine + "嗖嗖嗖...");
    }
}
```

VanCar

```
package com.wyqian.design.creatation.factory.factorymethod;
/**
 * 具体产品
 */
public class VanCar extends AbstractCar {
    public VanCar() {
        this.engine = "四缸发动机";
    }

    @Override
    public void run() {
        System.out.println(this.engine + "嘟嘟嘟...");
    }
}
```

3、抽象工厂

```
/**
 * 抽象工厂的层级
 */
public abstract class AbstractCarFactory {
    public abstract AbstractCar newCar();
}
```

4、具体工厂

MiniCarFactory专门造MiniCar

```
public class WuLinMiniCarFactory extends AbstractCarFactory{

    public AbstractCar newCar() {
        return new MiniCar();
    }
}
```

VanCarFactory专门造VanCar

```
public class WuLinVanCarFactory extends AbstractCarFactory{

    public AbstractCar newCar() {
        return new VanCar();
    }
}
```

RacingCarFactory专门造RacingCar

```
public class WuLinRacingCarFactory extends AbstractCarFactory{
    public AbstractCar newCar() {
        return new RacingCar();
    }
}
```

测试：

```
package com.wyqian.design.creatation.factory.factorymethod;

public class MainTest {
    public static void main(String[] args) {
        //造MiniCar
        AbstractCarFactory factory1 = new WuLinMiniCarFactory();
        AbstractCar car1 = factory1.newCar();
        car1.run();
        //造VanCar
        AbstractCarFactory factory2 = new WuLinVanCarFactory();
        AbstractCar car2 = factory2.newCar();
        car2.run();
        //造RacingCar
        AbstractCarFactory factory3 = new WuLinRacingCarFactory();
        AbstractCar car3 = factory3.newCar();
        car3.run();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621213622.png)

### 创建型模式-抽象工厂模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621215240.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621215354.png)

1、抽象产品-汽车

```
package com.wyqian.design.creatation.factory.abstractfactory;

public abstract class AbstractCar {
    String engine;
    public abstract void run();
}
```

2、汽车的具体产品—RacingCar

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class RacingCar extends AbstractCar {
    public RacingCar(){
        this.engine = "v8发动机";
    }
    public void run() {
        System.out.println(engine + "嗖嗖嗖...");
    }
}
```

3、汽车的具体产品—VanCar

```
package com.wyqian.design.creatation.factory.abstractfactory;

/**
 * 具体产品
 */
public class VanCar extends AbstractCar {
    public VanCar() {
        this.engine = "四缸发动机";
    }

    @Override
    public void run() {
        System.out.println(this.engine + "嘟嘟嘟...");
    }
}
```

4、抽象产品-口罩

```
package com.wyqian.design.creatation.factory.abstractfactory;

public abstract class AbstractMask {
    Integer price;
    public abstract void protectedMe();
}
```

5、口罩的具体产品–N95

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class N95Mask extends AbstractMask{
    public N95Mask(){
        this.price = 2;
    }
    public void protectedMe() {
        System.out.println("N95....超强防护！");
    }
}
```

6、口罩的具体产品–普通口罩

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class CommonMask extends AbstractMask{
    public CommonMask(){
        this.price = 1;
    }
    public void protectedMe() {
        System.out.println("普通口罩....普通防护！");
    }
}
```

7、抽象工厂—wulin集团

```
package com.wyqian.design.creatation.factory.abstractfactory;

public abstract class WuLinAbstractFactory {
    abstract AbstractCar newCar();
    abstract AbstractMask newMask();
}
```

8、抽象工厂—wulin汽车集团

```
package com.wyqian.design.creatation.factory.abstractfactory;

public abstract class WuLinCarFactory extends WuLinAbstractFactory {
    abstract AbstractCar newCar();

    AbstractMask newMask() {
        return null;
    }
}
```

9、抽象工厂—wulin口罩集团

```
package com.wyqian.design.creatation.factory.abstractfactory;

public abstract class WuLinMaskFactory extends WuLinAbstractFactory{
    AbstractCar newCar() {
        return null;
    }

    abstract AbstractMask newMask();
}
```

10、具体工厂–wulin RacingCar工厂

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class WuLinRacingCarFactory extends WuLinCarFactory {
    AbstractCar newCar() {
        return new RacingCar();
    }
}
```

11、具体工厂–wulin VanCar工厂

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class WuLinVanCarFactory extends WuLinCarFactory {
    AbstractCar newCar() {
        return new VanCar();
    }
}
```

12、具体工厂–wulin N95工厂

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class WuLinWuHanMaskFactory extends WuLinMaskFactory {
    AbstractMask newMask() {
        return new N95Mask();
    }
}
```

13、具体工厂–wulin 普通口罩工厂

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class WuLinHangZhouMaskFactory extends WuLinMaskFactory {
    AbstractMask newMask() {
        return new CommonMask();
    }
}
```

14、测试：

```
package com.wyqian.design.creatation.factory.abstractfactory;

public class MainTest {
    public static void main(String[] args) {
        //生产Racing Car
        WuLinAbstractFactory factory1 = new WuLinRacingCarFactory();
        AbstractCar car1 = factory1.newCar();
        car1.run();
        //生产Van Car
        WuLinAbstractFactory factory2 = new WuLinVanCarFactory();
        AbstractCar car2 = factory2.newCar();
        car2.run();
        //生产N95口罩
        WuLinAbstractFactory factory3 = new WuLinWuHanMaskFactory();
        AbstractMask mask1 = factory3.newMask();
        mask1.protectedMe();
        //生产普通口罩
        WuLinAbstractFactory factory4 = new WuLinHangZhouMaskFactory();
        AbstractMask mask2 = factory4.newMask();
        mask2.protectedMe();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210621221526.png)

### 创建型模式-工厂模式的思考

工厂模式的退化：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622112209.png)

工厂模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622112251.png)

### 创建型模式-建造者模式

普通建造者模式：

1、Phone

```
package com.wyqian.design.creatation.builder;

public class Phone {
    protected String cpu;
    protected String mem;
    protected String disk;
    protected String cam;

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", mem='" + mem + '\'' +
                ", disk='" + disk + '\'' +
                ", cam='" + cam + '\'' +
                '}';
    }

    public String getCpu() {
        return cpu;
    }

    public String getMem() {
        return mem;
    }

    public String getDisk() {
        return disk;
    }

    public String getCam() {
        return cam;
    }
}
```

2、抽象建造者

```
package com.wyqian.design.creatation.builder;

/**
 * 抽象建造者
 */
public abstract class AbstractBuilder {
    Phone phone;
    abstract void customCpu(String cpu);
    abstract void customMem(String mem);
    abstract void customDisk(String disk);
    abstract void customCam(String cam);
    Phone getProduct(){
        return phone;
    }
}
```

3、具体建造者

```
package com.wyqian.design.creatation.builder;

public class XiaomiBuilder extends AbstractBuilder{
    public XiaomiBuilder(){
        phone = new Phone();
    }

    void customCpu(String cpu) {
        phone.cpu = cpu;
    }

    void customMem(String mem) {
        phone.mem = mem;
    }

    void customDisk(String disk) {
        phone.disk = disk;
    }

    void customCam(String cam) {
        phone.cam = cam;
    }
}
```

4、测试

```
package com.wyqian.design.creatation.builder;

public class MainTest {
    public static void main(String[] args) {
        AbstractBuilder builder = new XiaomiBuilder();
        builder.customCam("1亿像素");
        builder.customCpu("骁龙888");
        builder.customDisk("256G");
        builder.customMem("16G");
        Phone product = builder.getProduct();
        System.out.println(product);
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622130112.png)

链式建造者模式：

把返回类型由void修改为本体。

1、phone 不变

2、抽象建造者

```
package com.wyqian.design.creatation.builder;

/**
 * 抽象建造者
 */
public abstract class AbstractBuilder {
    Phone phone;
    abstract AbstractBuilder customCpu(String cpu);
    abstract AbstractBuilder customMem(String mem);
    abstract AbstractBuilder customDisk(String disk);
    abstract AbstractBuilder customCam(String cam);
    Phone getProduct(){
        return phone;
    }
}
```

3、具体建造者

```
package com.wyqian.design.creatation.builder;

public class XiaomiBuilder extends AbstractBuilder{
    public XiaomiBuilder(){
        phone = new Phone();
    }

    AbstractBuilder customCpu(String cpu) {
        phone.cpu = cpu;
        return this;
    }

    AbstractBuilder customMem(String mem) {
        phone.mem = mem;
        return this;
    }

    AbstractBuilder customDisk(String disk) {
        phone.disk = disk;
        return this;
    }

    AbstractBuilder customCam(String cam) {
        phone.cam = cam;
        return this;
    }
}
```

4、测试

```
package com.wyqian.design.creatation.builder;

public class MainTest {
    public static void main(String[] args) {
        AbstractBuilder builder = new XiaomiBuilder();
        Phone product = builder.customMem("16G")
                .customDisk("256G")
                .customCpu("骁龙888")
                .customCam("1亿像素")
                .getProduct();
        System.out.println(product);
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622131056.png)

上面是我们自己写的链式建造者模式，lombok也为我们提供了类似的功能。

使用注解`@Builder`。

1、Phone修改为：

```
package com.wyqian.design.creatation.builder;

import lombok.Builder;

@Builder
public class Phone {
    protected String cpu;
    protected String mem;
    protected String disk;
    protected String cam;

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", mem='" + mem + '\'' +
                ", disk='" + disk + '\'' +
                ", cam='" + cam + '\'' +
                '}';
    }

    public String getCpu() {
        return cpu;
    }

    public String getMem() {
        return mem;
    }

    public String getDisk() {
        return disk;
    }

    public String getCam() {
        return cam;
    }
}
```

2、测试：

```
package com.wyqian.design.creatation.builder;

public class MainTest {
    public static void main(String[] args) {
        AbstractBuilder builder = new XiaomiBuilder();
        //自己写的链式建造者。
        Phone product = builder.customMem("16G")
                .customDisk("256G")
                .customCpu("骁龙888")
                .customCam("1亿像素")
                .getProduct();
        System.out.println(product);

        //lombok提供的链式建造者。
        Phone build = Phone.builder()
                .cam("1亿像素")
                .cpu("骁龙888")
                .disk("256G")
                .mem("16G")
                .build();
        System.out.println(build);
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622132109.png)

建造者模式的使用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622132420.png)

### 结构型模式-适配器模式

结构性模式有：

- 适配器模式
- 桥接模式
- 过滤器模式
- 组合模式
- 装饰器模式
- 外观模式
- 享元模式
- 代理模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622142027.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622142125.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622142150.png)

1、Player接口（即目标接口）

```
package com.wyqian.design.structural.adapter;

/**
 * 1、系统原有接口 player：可以播放电影，并且返回字幕
 */
public interface Player {
    String play();
}
```

2、Player实现类

```
package com.wyqian.design.structural.adapter;

/**
 * 电影播放器
 * 阅读器
 * ....
 */
public class MoviePlayer implements Player {
    public String play() {
        System.out.println("正在播放：宋老师的宝贵时间.avi");
        String content = "你好";
        System.out.println(content);//并且打印出字幕
        return content;
    }
}
```

3、Translator接口（适配者接口）：

```
package com.wyqian.design.structural.adapter;

/**
 * 2、系统原有接口，可以翻译文字内容
 */
public interface Translator {
    String translate(String content);
}
```

4、Translator类：

```
package com.wyqian.design.structural.adapter;

/**
 * ZH_JP翻译器
 * ZH_EN翻译器
 * .....
 */
public class Zh_JPTranslator implements Translator {
    public String translate(String content) {
        if("你好".equals(content)){
            return "空你吉娃";
        }else if("什么".equals(content)){
            return "纳尼";
        }
        return "******";
    }
}
```

5、JPMoviePlayerAdapter类（适配器类），这里采用类结构型模式

```
package com.wyqian.design.structural.adapter.clazz;

import com.wyqian.design.structural.adapter.Player;
import com.wyqian.design.structural.adapter.Zh_JPTranslator;

/**
 * 1、在原有系统上增加一个适配器。让适配器可以把电影的中文字幕翻译成友人理解的日文字幕
 *
 * 客户调用方法的时候用适配器操作即可。
 *
 * 类结构型模式：继承的方式，适配转换到了翻译器的功能上
 * 对象结构型模式：
 *
 */
public class JPMoviePlayerAdapter extends Zh_JPTranslator implements Player {
    private Player target;//目标对象
    public JPMoviePlayerAdapter(Player target){
        this.target = target;
    }
    public String play() {
        String play = target.play();
        //转换字幕
        String translate = translate(play);//调用适配者
        System.out.println("日文：" + translate);
        return play;
    }
}
```

6、JPMoviePlayerAdapter类（适配器类），这里采用对象结构型模式

```
package com.wyqian.design.structural.adapter.obj;

import com.wyqian.design.structural.adapter.Player;
import com.wyqian.design.structural.adapter.Translator;
import com.wyqian.design.structural.adapter.Zh_JPTranslator;

/**
 * 1、在原有系统上增加一个适配器。让适配器可以把电影的中文字幕翻译成友人理解的日文字幕
 *
 * 客户调用方法的时候用适配器操作即可。
 *
 * 类结构型模式：继承的方式，适配转换到了翻译器的功能上
 * 对象结构型模式：采用组合的方式
 *
 */
public class JPMoviePlayerAdapter implements Player {
    //组合的方式
    private Translator translator = new Zh_JPTranslator();
    private Player target;//目标对象
    public JPMoviePlayerAdapter(Player target){
        this.target = target;
    }
    public String play() {
        String play = target.play();
        //转换字幕
        String translate = translator.translate(play);//调用适配者
        System.out.println("日文：" + translate);
        return play;
    }
}
```

测试：

```
package com.wyqian.design.structural.adapter.clazz;

import com.wyqian.design.structural.adapter.MoviePlayer;

public class MainTest {
    public static void main(String[] args) {
        MoviePlayer player = new MoviePlayer();
        JPMoviePlayerAdapter adapter = new JPMoviePlayerAdapter(player);
        adapter.play();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622142621.png)

### 结构型模式-适配器一些场景

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622143243.png)

### 结构型模式-桥接模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622151045.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622151540.png)

1、抽象手机类

```
package com.wyqian.design.structural.bridge;
/**
 * 1、抽象手机类
 *  手机有各种销售渠道价格都不一样
 *
 */
public abstract class AbstractPhone {
    //桥接在此.....设计期间就得想好
    //【真正会引起此类变化的一个维度直接抽取出来，通过组合的方式接起来】
    //桥接+适配器 ...
    AbstractSale sale;//分离渠道【桥接的关注点】

    /**
     * 当前手机的描述
     * @return
     */
    abstract String getPhone();

    public void setSale(AbstractSale sale){
        this.sale = sale;
    }
}
```

2、抽象化接口的子类—IPhone

```
package com.wyqian.design.structural.bridge;

public class IPhone extends AbstractPhone{
    String getPhone() {
        return "IPhone：" + sale.getSaleInfo();
    }
}
```

3、另外一个维度—Sale（实现化接口）

```
package com.wyqian.design.structural.bridge;

/**
 * 抽象销售渠道
 * PhoneOnSale  ==howToSale
 * PhoneOffSale == howToSale
 * PhoneStudentSale = howToSale
 * PhonePDD == howToSale
 *
 *
 */
public class AbstractSale {
    private Integer price;
    private String type;

    public AbstractSale(Integer price, String type){
        this.price = price;
        this.type = type;
    }

    String getSaleInfo(){
        return "渠道："+type+"==>"+"价格："+price;
    }
}
```

4、实现化接口的具体实现类

```
package com.wyqian.design.structural.bridge;

/**
 * 线下渠道
 */
public class OfflineSale extends AbstractSale {
    public OfflineSale(Integer price, String type) {
        super(price, type);
    }
}
package com.wyqian.design.structural.bridge;

/**
 * 线上渠道
 */
public class OnlineSale extends AbstractSale {
    public OnlineSale(Integer price, String type) {
        super(price, type);
    }
}
```

5、测试

```
package com.wyqian.design.structural.bridge;

public class MainTest {
    public static void main(String[] args) {
        IPhone iPhone = new IPhone();
        iPhone.setSale(new OnlineSale(9999,"线上渠道"));
        String phone = iPhone.getPhone();
        System.out.println(phone);
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622151934.png)

### 结构型模式-理解适配器和装饰器

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622210459.png)

### 结构型模式-装饰器

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622212723.png)

1、抽象构件

```
package com.wyqian.design.structural.decorator;

/**
 * 抽象构建
 */
public interface ManTikTok {
    void tiktok();
}
```

2、具体构件

```
package com.wyqian.design.structural.decorator;

public class LeiTikTok implements ManTikTok {
    public void tiktok() {
        System.out.println("雷丰阳，tiktok......");
    }
}
```

3、抽象装饰

```
package com.wyqian.design.structural.decorator;

/**
 * 抽象装饰器
 * 抖音直播装饰器
 */
public interface TikTokDecorator extends ManTikTok{
    void enable();
}
```

4、具体装饰

```
package com.wyqian.design.structural.decorator;

/**
 * 美颜装饰器
 *      装饰谁？
 *
 *  装饰器只关系增强这个类的方法。
 */
public class MeiYanDecorator implements TikTokDecorator {
    private ManTikTok manTikTok;
    
    public MeiYanDecorator(ManTikTok manTikTok){
        this.manTikTok = manTikTok;
    }
    
    /**
     * 定义的增强功能
     */
    public void enable() {
        System.out.println("看这个美女");
        System.out.println("花花花花花花花......");
    }

    public void tiktok() {
        enable();
        manTikTok.tiktok();
    }
}
```

装饰器和适配器的主要区别就是装饰器只增强了这个类的功能，并没有连接两个类。而适配器则是连接了两个类，从而增强了某个类的功能。

装饰器的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622212803.png)

### 结构型模式-代理模式-静态代理

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622214434.png)

1、抽象主体

```
package com.wyqian.design.structural.proxy.statics;

/**
 * 抽象主体。被代理角色能干什么
 */
public interface ManTikTok {
    void tiktok();
}
```

2、真实主体

```
package com.wyqian.design.structural.proxy.statics;

/**
 * Subject  主体
 */
public class LeiTikTok implements ManTikTok {
    public void tiktok() {
        System.out.println("雷丰阳, tiktok......");
    }
}
```

3、代理主体

```
package com.wyqian.design.structural.proxy.statics;

/**
 * 代理一般都是和被代理对象属于同一个接口
 */
public class LeiTikTokProxy implements ManTikTok{
    private ManTikTok manTikTok;
    public LeiTikTokProxy(ManTikTok manTikTok){
        this.manTikTok = manTikTok;
    }

    /**
     * 宋喆（代理）  宝强（被代理对象）
     */
    public void tiktok() {
        //增强功能
        System.out.println("渲染直播间....");
        System.out.println("课程只要666，仅此一天....");
        manTikTok.tiktok();
    }
}
```

4、测试：

```
package com.wyqian.design.structural.proxy.statics;

public class MainTest {
    public static void main(String[] args) {
        ManTikTok manTikTok = new LeiTikTok();
        LeiTikTokProxy proxy = new LeiTikTokProxy(manTikTok);
        proxy.tiktok();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210622214602.png)

静态代理就是装饰器。

装饰器是静态代理的一种。

### 结构型模式-代理模式-jdk动态代理

静态代理的缺点：代理的东西不一样的时候，每一种不同的被代理类Person、Dog、Cat，需要创建不同的静态代理类。

1、抽象主体

```
package com.wyqian.design.structural.proxy.dynamic;

public interface ManTikTok {
    void tiktok();
}
package com.wyqian.design.structural.proxy.dynamic;

public interface SellTikTok {
    void sell();
}
```

2、真实主体

```
package com.wyqian.design.structural.proxy.dynamic;

public class LeiTikTok implements ManTikTok, SellTikTok{
    public void tiktok() {
        System.out.println("雷丰阳，tiktok......");
    }

    public void sell() {
        System.out.println("雷丰阳卖课ing......");
    }
}
```

3、获取代理对象

```
package com.wyqian.design.structural.proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JdkTikTokProxy<T> implements InvocationHandler {
    
    private T target;
    //接受被代理对象
    public JdkTikTokProxy(T target){
        this.target = target;
    }

    /**
     * 获取被代理对象的代理对象
     * @param t
     * @param <T>
     * @return
     */
    public static<T> T getProxy(T t){
        /**
         * ClassLoader loader,  当前被代理对象的类加载器
         * Class<?>[] interfaces,  当前被代理对象所实现的所有接口
         * InvocationHandler h  当前被代理对象执行目标方法的时候我们使用h可以定义拦截增强方法
         */
        Object o = Proxy.newProxyInstance(t.getClass().getClassLoader(),
                t.getClass().getInterfaces(),
                new JdkTikTokProxy(t));
        return (T)o;
    }
    /**
     * 定义目标方法的拦截逻辑，每个方法都会进来的
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //反射执行
        System.out.println("真正执行被代理对象的方法");
        Object invoke = method.invoke(target, args);
        System.out.println("返回值：一堆美女");
        return invoke;
    }
}
```

4、测试：

```
package com.wyqian.design.structural.proxy.dynamic;

/**
 * 动态代理模式：
 * JDK要求被代理对象必须有接口
 *
 * 代理对象和目标对象的相同点在于都是同一个接口
 */
public class MainTest {
    public static void main(String[] args) {
        ManTikTok leiTikTok = new LeiTikTok();

        /**
         * 动态代理机制
         */
        ManTikTok proxy = JdkTikTokProxy.getProxy(leiTikTok);
        proxy.tiktok();

        SellTikTok proxy1 = (SellTikTok) proxy;
        proxy1.sell();

    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623103451.png)

### 结构型模式-代理模式-cglib

1、本体

```
package com.wyqian.design.structural.proxy.cglib;

/**
 * Subject  主体
 */
public class LeiTikTok {
    public void tiktok(){
        System.out.println("雷丰阳，tiktok......");
    }
}
```

2、创建代理对象

```
package com.wyqian.design.structural.proxy.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 使用cglib为我们创建出代理对象
 */
public class CglibProxy {
    //为任意对象创建代理
    public static<T> T createProxy(T t){
        //1、创建一个增强器
        Enhancer enhancer = new Enhancer();
        
        //2、设置要增强哪个类的功能。增强器为这个类动态创建一个子类。
        enhancer.setSuperclass(t.getClass());
        
        //3、设置回调
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object o,
                                    Method method,  //为了能获取到原方法的一些元数据信息
                                    Object[] objects,
                                    MethodProxy methodProxy) throws Throwable {
                //编写拦截的逻辑
                System.out.println("cglib上场了......");
                
                //当前方法的信息
//                method.getAnnotation();
                //目标方法进行执行
                Object invoke = methodProxy.invokeSuper(o, objects);
                return invoke;
            }
        });
        Object o = enhancer.create();
        return (T)o;
    }
}
```

3、测试

```
package com.wyqian.design.structural.proxy.cglib;

public class MainTest {
    public static void main(String[] args) {
        LeiTikTok leiTikTok = new LeiTikTok();
        LeiTikTok proxy = CglibProxy.createProxy(leiTikTok);
        proxy.tiktok();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623165114.png)

### 结构型模式-代理模式-场景

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623170442.png)

装饰器和代理的区别：

- 装饰器和代理之间的区别很细微，可以人为装饰器是代理的一个子集。
- 静态代理就是装饰器的方式。

### 结构型模式-外观模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623172315.png)

1、Police

```
package com.wyqian.design.structural.facade;

public class Police {
    public void register(String name){
        System.out.println("公安局为" + name + "办理落户");
    }
}
```

2、Edu

```
package com.wyqian.design.structural.facade;

public class Edu {
    public void assignSchool(String name){
        System.out.println("教育局为" + name + "的小孩分配学校");
    }
}
```

3、Social

```
package com.wyqian.design.structural.facade;

public class Social {
    public void handleSocial(String name){
        System.out.println("社保局为" + name + "办理关系转移");
    }
}
```

4、WeiXinFacade

```
package com.wyqian.design.structural.facade;

public class WeiXinFacade {
    private Police police = new Police();
    private Edu edu = new Edu();
    private Social social = new Social();
    
    public void handleXXX(String name){
        police.register(name);
        edu.assignSchool(name);
        social.handleSocial(name);
    }
    
    //就算把他们分开写，也可以看成是外观模式，因为最后使用的时候只需new 一个对象，而不用三个。
    public void register(String name){
        police.register(name);
    }
    
    public void assignSchool(String name){
        edu.assignSchool(name);
    }
}
```

测试：

```
package com.wyqian.design.structural.facade;

public class MainTest {
    public static void main(String[] args) {
        WeiXinFacade facade = new WeiXinFacade();
        facade.handleXXX("雷丰阳");
    }
    
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623172544.png)

### 结构型模式-享元模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623175039.png)

享元模式主要用于减少创建对象的数量，用HashMap存储这些对象。

1、Shape接口

```
package com.wyqian.design.structural.flyweight;

public interface Shape {
    void draw();
}
```

2、Circle类

```
package com.wyqian.design.structural.flyweight;

public class Circle implements Shape{
    private String color;
    private int x;
    private int y;
    private int radius;
    
    public Circle(String color){
        this.color = color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    public void draw() {
        System.out.println("Circle: Draw() [Color : " + color
                +", x : " + x +", y :" + y +", radius :" + radius);
    }
}
```

3、ShapeFactory

```
package com.wyqian.design.structural.flyweight;

import java.util.HashMap;

public class ShapeFactory {
    private static final HashMap<String, Shape> circleMap = new HashMap();
    
    public static Shape getCircle(String color){
        Circle circle = (Circle)circleMap.get(color);
        
        if(circle == null){
            circle = new Circle(color);
            circleMap.put(color, circle);
            System.out.println("Creating circle of color:" + color);
        }
        return circle;
    }
}
```

4、测试

```
package com.wyqian.design.structural.flyweight;

public class FlyweightPatternDemo {
    private static final String colors[] = {"red", "blue", "Green"};

    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
    }
    
    private static String getRandomColor(){
        return colors[(int)(Math.random()*colors.length)];
    }
    
    private static int getRandomX(){
        return (int)(Math.random()*100);
    }

    private static int getRandomY(){
        return (int)(Math.random()*100);
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623194024.png)

内部状态在这里指的就是color，外部状态就是指位置和坐标。

 我们举一个最简单的例子，棋牌类游戏大家都有玩过吧，比如说说围棋和跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色略多一点，但也是不太变化的，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，我们落子嘛，落子颜色是定的，但位置是变化的，所以方位坐标就是棋子的外部状态。

　　那么为什么这里要用享元模式呢？可以想象一下，上面提到的棋类游戏的例子，比如围棋，理论上有361个空位可以放棋子，常规情况下每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。

享元和原型的区别：

1. 享元返回的是这个本人。
2. 原型返回的是克隆人。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623195147.png)

### 行为模式-模板模式

行为型模式有：

- 模板方法模式
- 策略模式
- 状态模式
- 中介者模式
- 观察者模式
- 备忘录模式
- 解释器模式
- 命令模式
- 迭代器模式
- 访问者模式
- 职责链模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623201034.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623201054.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623201129.png)

1、抽象模板

```
package com.wyqian.design.behavioral.template;

/**
 * 定义模板
 */
public abstract class CookTemplate {
    /**
     * 定义算法：  定义好了模板
     * 父类可以实现某些步骤
     * 留关键给子类
     */
    public void cook(){
        heating();
        addFood();
        addSalt();
        stirfry();
        end();
    }
    
    //加热方法
    public void heating(){
        System.out.println("开火......");
    }
    
    //添加食物
    public abstract void addFood();
    
    //加盐
    public abstract void addSalt();
    
    //翻炒
    public void stirfry(){
        System.out.println("翻炒......");
    }
    
    //出锅
    public void end(){
        System.out.println("出锅!");
    }
}
```

2、具体实现

```
package com.wyqian.design.behavioral.template;

public class AutoCookMachine extends CookTemplate {
    public void addFood() {
        System.out.println("加了三颗小白菜");
    }

    public void addSalt() {
        System.out.println("加了三勺盐");
    }
}
```

3、测试

```
package com.wyqian.design.behavioral.template;

public class MainTest {
    public static void main(String[] args) {
        CookTemplate autoCookMachine = new AutoCookMachine();
        autoCookMachine.cook();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623201243.png)

模板模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623201329.png)

### 行为型模式-策略模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623203309.png)

1、抽象策略

```
package com.wyqian.design.behavioral.strategy;

/**
 * 游戏策略
 */
public interface GameStrategy {
    //战斗策略
    void warStrategy();
}
```

2、具体策略1-SteadyStrategy

```
package com.wyqian.design.behavioral.strategy;

/**
 * 稳健运营策略
 */
public class SteadyStrategy implements GameStrategy {
    public void warStrategy() {
        System.out.println("各路小心，及时支援......");
    }
}
```

3、具体策略2-UziStrategy

```
package com.wyqian.design.behavioral.strategy;

/**
 * 冲锋向前策略
 */
public class UziStrategy implements GameStrategy{

    public void warStrategy() {
        System.out.println("uzi......");
    }
}
```

4、环境类

```
package com.wyqian.design.behavioral.strategy;


/**
 * 环境类
 */
public class TeamGNR {
    //抽取游戏策略算法，并进行引用
    private GameStrategy gameStrategy;
    
    public void setGameStrategy(GameStrategy gameStrategy){
        this.gameStrategy = gameStrategy;
    }
    
    public void startGame(){
        System.out.println("游戏开始......");
        //游戏策略
        gameStrategy.warStrategy();
        System.out.println("win......");
    }
}
```

5、测试

```
package com.wyqian.design.behavioral.strategy;

public class MainTest {
    public static void main(String[] args) {
        TeamGNR teamGNR = new TeamGNR();
        teamGNR.setGameStrategy(new UziStrategy());
        teamGNR.startGame();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623203504.png)

策略模式使用的场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623203913.png)

线程池拒绝策略：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623204047.png)

### 行为型模式-状态模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623210525.png)

1、抽象状态

```
package com.wyqian.design.behavioral.state;

/**
 * 抽象状态
 */
public interface TeamState {
    //玩游戏
    void playGame();
    
    //切换到下一个状态
    TeamState next();
}
```

2、具体状态

```
package com.wyqian.design.behavioral.state;

/**
 * 休假状态
 */
public class VocationState implements TeamState {
    public void playGame() {
        System.out.println("三亚旅游真舒服....饿了...不玩游戏");
    }

    public TeamState next() {
        return new BeefNoodlesState();
    }
}
package com.wyqian.design.behavioral.state;

public class MatchState implements TeamState {
    public void playGame() {
        System.out.println("全力以赴打比赛....");
    }

    public TeamState next() {
        return new VocationState();
    }
}
package com.wyqian.design.behavioral.state;

public class BeefNoodlesState implements TeamState {
    public void playGame() {
        System.out.println("饱饱的一顿牛肉面......中了诅咒，输了");
    }

    public TeamState next() {
        return new MatchState();
    }
}
```

3、环境类

```
package com.wyqian.design.behavioral.state;

/**
 * 环境类：
 */
public class SKTTeam {
    private TeamState teamState;

    public void setTeamState(TeamState teamState) {
        this.teamState = teamState;
    }
    
    //开始游戏
    public void startGame(){
        //状态不同个会导致不同的游戏结果
        teamState.playGame();
    }
    
    //下一个状态
    void nextState(){
        teamState = teamState.next();
    }
}
```

4、测试

```
package com.wyqian.design.behavioral.state;

public class MainTest {
    public static void main(String[] args) {
        SKTTeam sktTeam = new SKTTeam();
        VocationState state = new VocationState();
        sktTeam.setTeamState(state);
        sktTeam.startGame();
        sktTeam.nextState();
        sktTeam.startGame();
        sktTeam.startGame();
        sktTeam.nextState();
        sktTeam.startGame();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623210759.png)

状态模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623210843.png)

### 行为型模式-中介者模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623212142.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623212215.png)

1、抽象同事类

```
package com.wyqian.design.behavioral.mediator;

/**
 * 抽象机长
 */
public abstract class Captain {
    
    //起飞
    abstract void fly();
    //降落
    abstract void land();
    //完成
    abstract void success();
}
```

2、具体同事类

```
package com.wyqian.design.behavioral.mediator;

public class HU8778 extends Captain{
    private ControlTower controlTower;

    public void setControlTower(ControlTower controlTower) {
        this.controlTower = controlTower;
    }

    void fly() {
        System.out.println("HU8778请求起飞......");
        //问塔台是否能起飞
        controlTower.acceptRequest(this, "fly");
    }

    void land() {
        System.out.println("HU8778请求降落......");
        controlTower.acceptRequest(this, "fly");
    }

    void success() {
        System.out.println("完成......");
        controlTower.acceptRequest(this, "fly");
    }
}
package com.wyqian.design.behavioral.mediator;

public class SC8633 extends Captain{
    private ControlTower controlTower;

    public void setControlTower(ControlTower controlTower) {
        this.controlTower = controlTower;
    }
    
    void fly() {
        System.out.println("SC8633请求起飞......");
        controlTower.acceptRequest(this, "fly");
    }

    void land() {
        System.out.println("SC8633请求降落......");
        controlTower.acceptRequest(this, "fly");
    }

    void success() {
        System.out.println("完成......");
        controlTower.acceptRequest(this, "fly");
    }
}
package com.wyqian.design.behavioral.mediator;

public class XC9527 extends Captain{

    private ControlTower controlTower;

    public void setControlTower(ControlTower controlTower) {
        this.controlTower = controlTower;
    }
    
    void fly() {
        System.out.println("XC9527请求起飞......");
        controlTower.acceptRequest(this, "fly");
    }

    void land() {
        System.out.println("XC9527请求降落......");
        controlTower.acceptRequest(this, "fly");
    }

    void success() {
        System.out.println("完成......");
        controlTower.acceptRequest(this, "fly");
    }
}
```

3、中介者

```
package com.wyqian.design.behavioral.mediator;

/**
 * 塔台：中介者
 *
 * 网状变为星状
 */
public class ControlTower {
    private boolean canDo = true;
    
    //接受请求
    public void acceptRequest(Captain captain, String action){
        if("fly".equals(action) || "land".equals(action)){
            if(canDo == true){
                System.out.println("允许" + action);
                this.canDo = false;
            }else{
                System.out.println("不允许" + action);
            }
        }
        if("success".equals(action)){
            canDo = true;
        }
    }
}
```

4、测试

```
package com.wyqian.design.behavioral.mediator;

public class MainTest {
    public static void main(String[] args) {
        ControlTower controlTower = new ControlTower();
        HU8778 hu8778 = new HU8778();
        hu8778.setControlTower(controlTower);
        SC8633 sc8633 = new SC8633();
        sc8633.setControlTower(controlTower);
        
        hu8778.fly();
        sc8633.fly();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623213837.png)

中介者模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623212238.png)

### 行为型模式-观察者模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623215004.png)

1、抽象观察者

```
package com.wyqian.design.behavioral.observer;

/**
 * 抽象观察者
 */
public abstract class AbstractFans {
    //接收消息
    abstract void acceptMsg(String msg);
    
    void follow(AbstractTikToker tikToker){
        //主播增粉了
        tikToker.addFans(this);
    }
}
```

2、具体观察者

```
package com.wyqian.design.behavioral.observer;

public class HumanFans extends AbstractFans {
    void acceptMsg(String msg) {
        System.out.println("主播说：" + msg);
    }
}
package com.wyqian.design.behavioral.observer;

public class RobotFans extends AbstractFans {
    void acceptMsg(String msg) {
        System.out.println("呸......");
    }
}
```

3、抽象目标

```
package com.wyqian.design.behavioral.observer;

/**
 * 抖音主播
 *
 * 粉丝观察主播....
 */
public abstract class AbstractTikToker {
    
    //添加粉丝
    abstract void addFans(AbstractFans fans);
    
    //通知粉丝
    abstract void notifyFans(String msg);
}
```

4、具体目标

```
package com.wyqian.design.behavioral.observer;

import java.util.ArrayList;
import java.util.List;

public class MMTikToker extends AbstractTikToker {
    
    //1、观察者的核心
    List<AbstractFans> fansList = new ArrayList();
    
    void startSell(){
        System.out.println("雷丰阳开始卖货......");
        notifyFans("我开始卖东西了，只要666");
    }
    
    void endSell(){
        System.out.println("雷丰阳结束卖货");
        notifyFans("课已经卖完了，记得五星好评！");
    }

    public void addFans(AbstractFans fans) {
        fansList.add(fans);
    }

    public void notifyFans(String msg) {
        //1、所有粉丝拿来通知
        for (AbstractFans fans : fansList) {
            fans.acceptMsg(msg);
        }
    }
}
```

5、测试

```
package com.atguigu.design.behavioral.observer;

public class MainTest {

    public static void main(String[] args) {

        MMTikToker lei = new MMTikToker();

        lei.startSell();

        RobotFans fans1 = new RobotFans();
        RobotFans fans2 = new RobotFans();
        RobotFans fans3 = new RobotFans();
        fans1.follow(lei);
        fans2.follow(lei);
        fans3.follow(lei);

        HumanFans humanFans = new HumanFans();
        humanFans.follow(lei);

        System.out.println("=====>");


        lei.endSell();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623221103.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623221119.png)

### 行为型模式-备忘录模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625125847.png)

1、发起人角色：

```
package com.wyqian.design.behavioral.memento;

public class Originator {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
    
    public Memento saveStateToMemento(){
        Memento memento = new Memento(state);
        return memento;
    }
    
    public void getStateFromMemento(Memento memento){
        state = memento.getState();
    }
}
```

2、备忘录角色

```
package com.wyqian.design.behavioral.memento;

public class Memento {
    private String state;
    
    public Memento(String state){
        this.state = state;
    }
    
    public String getState(){
        return state;
    }
}
```

3、管理者角色

```
package com.wyqian.design.behavioral.memento;

import java.util.ArrayList;
import java.util.List;

public class CareTaker {
    private List<Memento> mementoList = new ArrayList<Memento>();
    
    public void add(Memento state){
        mementoList.add(state);
    }
    
    public Memento get(int index){
        return mementoList.get(index);
    }
}
```

4、测试

```
package com.wyqian.design.behavioral.memento;

public class MainTest {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState("State1");
        originator.setState("State2");
        
        careTaker.add(originator.saveStateToMemento());
        
        originator.setState("State3");
        careTaker.add(originator.saveStateToMemento());
        
        originator.setState("State4");

        System.out.println("Current State:" + originator.getState());
        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved State:" + originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved State:" + originator.getState());
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625131400.png)

备忘录的应用场景：

- 游戏存档
- 数据库保存点事务
- session活化钝化
- windows里面的ctrl + z

### 行为型模式-解释器模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625132441.png)

1、Expression接口

```
package com.wyqian.design.behavioral.interpreter;

public interface Expression {
    public boolean interpret(String context);
}
```

2、AndExpression

```
package com.wyqian.design.behavioral.interpreter;

public class AndExpression implements Expression {
    private Expression expr1 = null;
    private Expression expr2 = null;

    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    public boolean interpret(String context) {
        return expr1.interpret(context) && expr2.interpret(context);
    }
}
```

3、OrExpression

```
package com.wyqian.design.behavioral.interpreter;

public class OrExpression implements Expression {
    
    private Expression expr1 = null;
    private Expression expr2 = null;

    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    public boolean interpret(String context) {
        return expr1.interpret(context) || expr2.interpret(context);
    }
}
```

4、TerminalExpression

```
package com.wyqian.design.behavioral.interpreter;

public class TerminalExpression implements Expression {
    private String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    public boolean interpret(String context) {
        if(context.contains(data)){
            return true;
        }else{
            return false;
        }
    }
}
```

5、测试

```
package com.wyqian.design.behavioral.interpreter;

public class MainTest {
    //规则：Robert 和 John 是男性
    public static Expression getMaleExpression(){
        TerminalExpression robert = new TerminalExpression("Robert");
        TerminalExpression john = new TerminalExpression("John");
        return new OrExpression(robert, john);
    }


    //规则：Julie是一个已婚的女性
    public static Expression getMarriedWomanExpression(){
        TerminalExpression julie = new TerminalExpression("Julie");
        TerminalExpression married = new TerminalExpression("Married");
        return new AndExpression(julie, married);
    }
    public static void main(String[] args) {
        Expression isMale = getMaleExpression();
        Expression isMarriedWoman = getMarriedWomanExpression();

        System.out.println("John is male?" + isMale.interpret("John"));
        System.out.println("Julie is a married women?" + isMarriedWoman.interpret("Married Julie"));
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625135546.png)

**抽象解释器**：具体的解释任务由各个实现类完成。

**终结符表达式**：实现与文法中的元素相关联的解释操作，通常一个解释器模式只有一个终结表达式，但有多个实例，对应不同的终结符。比如变量a对应一个终结符，变量b对应另一个终结符。

**非终结表达式**：文法中每一条规则对应一个非终结表达式。

**上下文**：上下文环境类，包含解释器之外的全局信息。

**客户类**：客户端，解析表达式，构建抽象语法树，执行具体的解释操作等。

解释器模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625143046.png)

### 行为型模式-命令模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625144131.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625144149.png)

1、调用者（相当于controller）

```
package com.wyqian.design.behavioral.command;

/**
 * 命令的发起者
 */
public class TeacherTongInvoke {
    Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void call(){
        command.execute();
    }
}
```

2、抽象命令（相当于Service）

```
package com.wyqian.design.behavioral.command;

/**
 * 抽象命令类
 */
public interface Command {
    /**
     * 命令的执行方法
     */
    void execute();
}
```

3、具体命令(相当于ServiceImpl)

```
package com.wyqian.design.behavioral.command;

public class OnlineCommand implements Command {
    private LeiReceiver leiReceiver = new LeiReceiver();
    public void execute() {
        System.out.println("要去上课了...");
        leiReceiver.online();
    }
}
package com.wyqian.design.behavioral.command;

public class WuHanTravelCommand implements Command {
    private LeiReceiver leiReceiver = new LeiReceiver();
    
    public void execute() {
        System.out.println("要去出差了...");
        leiReceiver.travel();
    }
}
```

4、实现者（相当于dao）

```
package com.wyqian.design.behavioral.command;

/**
 * 命令执行者
 */
public class LeiReceiver {
    public void online(){
        System.out.println("雷丰阳在上课");
    }
    public void travel(){
        System.out.println("雷丰阳在出差");
    }
}
```

5、测试

```
package com.wyqian.design.behavioral.command;

public class MainTest {
    public static void main(String[] args) {
        TeacherTongInvoke invoke = new TeacherTongInvoke();
        invoke.setCommand(new OnlineCommand());
        
        invoke.call();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625150103.png)

命令模式的应用场景：

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625150137.png)

### 行为型模式-迭代器模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625151351.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625151428.png)

抽象聚合、抽象迭代器、具体迭代器

```
package com.wyqian.design.behavioral.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * 抽象聚合类
 */
public abstract class BeautifulMan {
    //不方便暴露给外界的集合。只允许外界获取而不可以操作
    private List<String> girlFriends = new ArrayList();
    
    void likeYou(String name){
        girlFriends.add(name);
    }
    
    void sayBye(String name){
        girlFriends.remove(name);
    }

    public Itr getIterator(){
        return new Iterator();
    }
    
    /**
     * 具体迭代器
     */
    class Iterator implements Itr{
        
        private int cursor = 0;//当前指针

        public boolean hasNext() {
            return cursor < girlFriends.size();
        }

        public String next() {
            //第一次调用返回第一个数据
            //下一次再调用自动访问下一个数据
            String next = girlFriends.get(cursor);
            cursor++;
            return next;
        }

        public String firstLove() {
            return girlFriends.get(0);
        }

        public String current() {
            return girlFriends.get(girlFriends.size()-1);
        }
    }

    /**
     * 抽象迭代器
     */
    interface Itr{
        //有没有下一个
        boolean hasNext();
        
        //返回下一个
        String next();
        
        //返回初恋
        String firstLove();
        
        //返回现任
        String current();
    }
    
}
```

具体聚合

```
package com.wyqian.design.behavioral.iterator;

public class ManYuCheng extends BeautifulMan{
}
```

测试：

```
package com.wyqian.design.behavioral.iterator;

public class MainTest {
    public static void main(String[] args) {
        ManYuCheng cheng = new ManYuCheng();
        
        cheng.likeYou("ZhangTianYu");
        cheng.likeYou("WangKang");
        cheng.likeYou("QianWanYun");

        BeautifulMan.Itr itr = cheng.getIterator();

        System.out.println(itr.firstLove());
        
        while(itr.hasNext()){
            System.out.println(itr.next());
        }
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625153623.png)

### 行为型模式-访问者模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625155822.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625162037.png)

1、抽象元素

```
package com.wyqian.design.behavioral.visitor;

/**
 * 硬件。      抽象元素类
 */
public abstract class Hardware {
    String command;//封装硬件的处理指令

    public Hardware(String command) {
        this.command = command;
    }
    
    //收到命令之后进行工作
    abstract public void work();

    //定义接受软件升级包的方法。这个方法应该具体硬件去实现
    abstract public void accept(Visitor visitor);
}
```

2、具体元素

```
package com.wyqian.design.behavioral.visitor;

public class Foot extends Hardware{

    public Foot(String command) {
        super(command);
    }

    public void work() {
        System.out.println("脚处理指令："+command);
    }

    public void accept(Visitor visitor) {
        visitor.visitFoot(this);
    }
}
package com.wyqian.design.behavioral.visitor;

public class CPU extends Hardware{

    public CPU(String command) {
        super(command);
    }

    public void work() {
        System.out.println("CPU处理指令："+command);
    }

    public void accept(Visitor visitor) {
        //给升级包提供一个改CPU指令等信息的办法
        visitor.visitCPU(this);
    }
}
package com.wyqian.design.behavioral.visitor;

public class Disk extends Hardware{

    public Disk(String command) {
        super(command);
    }

    public void work() {
        System.out.println("Disk保存指令的历史记录："+command);
    }

    public void accept(Visitor visitor) {
        visitor.visitDisk(this);
    }
}
```

3、对象结构

```
package com.wyqian.design.behavioral.visitor;

/**
 * 小爱机器人
 */
public class XiaoMi {
    private CPU cpu = new CPU("武汉天气");
    private Disk disk = new Disk("武汉天气");
    private Foot foot = new Foot("武汉天气");
    
    void answerQuestion(){
        cpu.work();
        disk.work();
        foot.work();
    }
    
    //接收升级包
    public void acceptPackage(Visitor aPackage){
        aPackage.visitCPU(cpu);
        aPackage.visitDisk(disk);
        aPackage.visitFoot(foot);
    }
}
```

4、抽象访问者

```
package com.wyqian.design.behavioral.visitor;

/**
 * 升级包的接口
 */
public interface Visitor {
    
    //访问者能访问元素
    void visitCPU(CPU cpu);
    void visitDisk(Disk disk);
    void visitFoot(Foot foot);
}
```

5、具体访问者

```
package com.wyqian.design.behavioral.visitor;

public class UpdatePackage implements Visitor {
    
    private String ext;

    public UpdatePackage(String ext) {
        this.ext = ext;
    }

    public void visitCPU(CPU cpu) {
        cpu.command += ">>>" + ext;
    }

    public void visitDisk(Disk disk) {
        disk.command += ">>>" + ext;
    }

    public void visitFoot(Foot foot) {
        foot.command += ">>>" + ext;
    }
}
```

6、测试

```
package com.wyqian.design.behavioral.visitor;

public class MainTest {
    public static void main(String[] args) {
        XiaoMi xiaoMi = new XiaoMi();
        
        xiaoMi.answerQuestion();
        
        //升级，cpu联网
        //升级，disk保存到云存储
        UpdatePackage aPackage = new UpdatePackage("联网增强功能");
        xiaoMi.acceptPackage(aPackage);


        xiaoMi.answerQuestion();

    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625162232.png)

访问者模式不多见。违反开闭原则和依赖倒置原则。

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625162419.png)

### 行为型模式-职责链模式

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625163855.png)

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625163911.png)

```
package com.wyqian.design.behavioral.chain;

public class Teacher {
    private String name;
    //下一个处理的老师；1、链条的引用点
    private Teacher next;

    public Teacher(String name) {
        this.name = name;
    }

    public void setChain(Teacher next) {
        this.next = next;
    }
    
    public void handleRequest(){
        System.out.println(this + "正在处理......");
        if(next != null){
            //2、下一个继续
            next.handleRequest();
        }
    }

    @Override
    public String toString() {
        return "Teacher{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

测试：

```
package com.wyqian.design.behavioral.chain;

public class MainTest {
    public static void main(String[] args) {
        Teacher 钱万云 = new Teacher("钱万云");
        Teacher 张总 = new Teacher("张总");
        Teacher 王总 = new Teacher("王总");
        
        //3、设置链条
        钱万云.setChain(张总);
        张总.setChain(王总);
        
        钱万云.handleRequest();
    }
}
```

![img](https://gitee.com/Curryforthreeeeee30/HexoPicture/raw/master/PicturteBed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210625163957.png)